
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to check user roles
    function isUserRole(targetRole) {
      let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
      return request.auth != null &&
             exists(userDocPath) &&
             get(userDocPath).data.role == targetRole;
    }

    function isAdmin() { return isUserRole('admin'); }
    function isTeacher() { return isUserRole('teacher'); }
    function isStudent() { return isUserRole('student'); }
    function isParent() { return isUserRole('parent'); }

    // Helper function to check if role is being changed (for updates)
    function isNotChangingRole(updatedData) {
      // If 'role' is not in updatedData, it's not being changed.
      // If 'role' is in updatedData, it must be the same as the existing role.
      return !('role' in updatedData) || updatedData.role == resource.data.role;
    }

    // Users collection:
    match /users/{userId} {
      // Rule 1: Allow an authenticated user to read their own document.
      allow read: if request.auth != null && request.auth.uid == userId;
      // Rule 2: Allow an admin to read any user document. (This is additive to Rule 1)
      allow read: if request.auth != null && isAdmin();

      // Only admin can create user documents (as per current app flow)
      allow create: if request.auth != null && isAdmin();
      // Users can update their own document (but not their role, unless they are an admin)
      // Admins can update any user document (including roles)
      allow update: if request.auth != null && (
                      (request.auth.uid == userId && isNotChangingRole(request.resource.data)) || isAdmin()
                    );
      // Only admins can delete user documents.
      allow delete: if request.auth != null && isAdmin();
    }

    // Students collection
    match /students/{studentId} {
      allow read: if request.auth != null && (
                    isAdmin() ||
                    isTeacher() ||
                    (isStudent() && request.auth.uid == studentId) ||
                    (isParent() && isChildOfParent(studentId)) // Assumes isChildOfParent correctly checks linkage
                  );
      allow create, update: if request.auth != null && isAdmin();
      allow delete: if request.auth != null && isAdmin();
    }

    // Teachers collection
    match /teachers/{teacherId} {
      allow read: if request.auth != null && (
                    isAdmin() ||
                    (isTeacher() && request.auth.uid == teacherId)
                  );
      allow create, update: if request.auth != null && isAdmin();
      allow delete: if request.auth != null && isAdmin();
    }

    // Classes collection
    match /classes/{classId} {
      allow read: if request.auth != null && (isAdmin() || isTeacher());
      allow create, update, delete: if request.auth != null && isAdmin();
    }

    // Subjects collection
    match /subjects/{subjectId} {
      allow read: if request.auth != null && (isAdmin() || isTeacher());
      allow create, update, delete: if request.auth != null && isAdmin();
    }

    // Notifications collection
    match /notifications/{notificationId} {
      allow read: if request.auth != null; // All authenticated users can read notifications
      allow create, update, delete: if request.auth != null && isAdmin();
    }

    // attendanceRecords collection
    // Note: request.resource.data.studentId is used for read security on specific records
    match /attendanceRecords/{recordId} {
      allow read: if request.auth != null && (
                    isAdmin() ||
                    isTeacher() || // Teachers might need to list attendance for their classes
                    (isStudent() && request.resource.data.studentId == request.auth.uid) ||
                    (isParent() && isChildOfParent(request.resource.data.studentId))
                  );
      // For list operations (querying multiple records), you might need broader list access for teachers
      // e.g., allow list: if isTeacher() && request.query.filters involve their classId; (more complex)
      allow create, update: if request.auth != null && (isAdmin() || isTeacher());
      allow delete: if request.auth != null && isAdmin();
    }

    // gradeRecords collection
    match /gradeRecords/{recordId} {
      allow read: if request.auth != null && (
                    isAdmin() ||
                    isTeacher() ||
                    (isStudent() && request.resource.data.studentId == request.auth.uid) ||
                    (isParent() && isChildOfParent(request.resource.data.studentId))
                  );
      allow create, update: if request.auth != null && (isAdmin() || isTeacher());
      allow delete: if request.auth != null && isAdmin();
    }

    // feeRecords collection
    match /feeRecords/{feeId} {
      allow read: if request.auth != null && (
                    isAdmin() ||
                    (isParent() && isChildOfParent(request.resource.data.studentId))
                  );
      allow create, update, delete: if request.auth != null && isAdmin();
    }

    // Placeholder for parent-child relationship check
    // This needs actual implementation based on your data structure for linking parents to children
    function isChildOfParent(studentIdFromRecord) {
      // Example: return exists(/databases/$(database)/documents/parents/$(request.auth.uid)/children/$(studentIdFromRecord));
      // Or: return get(/databases/$(database)/documents/students/$(studentIdFromRecord)).data.parentUids[request.auth.uid] == true;
      // For now, returning true if user is a parent for testing. THIS IS INSECURE FOR PRODUCTION.
      return isParent(); // REPLACE WITH ACTUAL SECURE LOGIC
    }
  }
}
